/* autogenerated by Processing revision 1289 on 2023-12-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.stream.Collectors;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ChessEngine extends PApplet {



float s;

Board board = new Board();
BoardUI boardUI;

MoveGenerator moveGenerator;

int moveNumber = 0;
boolean gameOver = false;

int tgtSquare = -1000;
int selectedSquare = -1000;

KetchupCrewV1 botV1 = new KetchupCrewV1();
KetchupCrewV2 botV2 = new KetchupCrewV2();


int LARGENUMBER = 100000000;

String gameOverText;
public void setup() {
  /* size commented out by preprocessor */;
  s = width/8.0f;
  setupImages();
  computeMoveData();

  /*Example Fens:
   ini pos:rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq
   2r1r2k/2nb1ppp/3Ppq2/p1ppnp1p/1pBRPN2/P1P5/1P2QPPP/2B1R1K1
   8/b1n1k3/2rppp1n/8/5PP1/N3P3/6K1/B2N1R2
   r3k2r/ppp4P/PPP5/8/8/8/8/5K2
   rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8
   //forced draw:7k/6p1/8/4Q3/pppp4/qqqp4/pppp1PPP/6RK w
   */
  board = fenToBoard("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq");
  boardUI = new BoardUI(board, new PVector(0, 0), 800, color(238, 238, 210), color(118, 150, 86));

  moveGenerator = new MoveGenerator();
  //frameRate(2);
  moveGenerator.generateLegalMoves(board);


  initializeSound();
}

public void draw() {
  //println(moveGenerator.inCheck());

  if (gameOver) {
    boardUI.showSquares();
    moveGenerator.showPieceMoves(selectedSquare);
    boardUI.showPieces();
    boardUI.showGameOverText();
    if (key == 'r' || key == 'R') {
      gameOver = false;
      board = fenToBoard("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq");
      boardUI.playedMove=null;
      moveGenerator.generateLegalMoves(board);

      deSelectPiece();
    }
    return;
  }


  if (!board.whiteTurn && boardUI.animationDone) {
    moveGenerator.generateLegalMoves(board);
    KetchupCrewV1.Result result=botV1.search(4, moveGenerator.moves.get(0));
    boardUI.playMove(result.move);

    board.makeMove(result.move);
    board.printGameState();
    if (!board.draw)moveGenerator.generateLegalMoves(board);
    if (checkGameOver())return;
    println("Evaluation for " + (board.whiteTurn? "white : " : "black : ")+ evaluate());
  }

  reRenderBoard();
}

public void mousePressed() {
  if (gameOver) return;
  if (mouseButton == LEFT) {
    int xCoord = (int)(mouseX/s);
    int yCoord = (int)(mouseY/s);
    if (getColor(board.squares[xCoord + yCoord * 8])==board.colorToMove|| selectedSquare == -1000) {
      selectedSquare = xCoord + yCoord * 8;
      return;
    } else
      tgtSquare = xCoord + yCoord * 8;
    Move m = getMoveWithCoord(selectedSquare, tgtSquare);
    if (!board.draw && m != null) {
      //println(PAWN_VALUES[0][1][36]);
      boardUI.playMove(m);
      board.makeMove(m);
      board.printGameState();
      moveGenerator.generateLegalMoves(board);
      if (checkGameOver())return;
      println("Evaluation for " + (board.whiteTurn? "white : " : "black : ")+ evaluate());

      reRenderBoard();
      deSelectPiece();
    } else {
      deSelectPiece();
    }
  } else if (mouseButton == RIGHT) {
    deSelectPiece();
  }
}
public void checkmated(boolean player) {
  gameOver = true;
  if (player == true) println("Black is victorious. White is checkmated.");
  if (player == false) println("White is victorious. Black is checkmated.");
  gameOverText = "Checkmate!\n Press R to restart.";
}
public void stalemate() {
  gameOver = true;
  println("Game drawed due to stalemate.");
  gameOverText = "Stalemate!\n Press R to restart.";
}
public void drawByRule() {
  gameOver=true;
  println("Draw By Repetition or Fifty Move Rule.");
  gameOverText = "Draw!\n Press R to restart.";
}

public boolean checkGameOver() {

  if (moveGenerator.moves.size() == 0) {
    if (moveGenerator.inCheck())checkmated(board.whiteTurn);
    else stalemate();

    return true;
  } else if (board.draw) {
    drawByRule();
    return true;
  }
  return false;
}


public void reRenderBoard() {
  background(0);
  boardUI.showSquares();
  moveGenerator.showPieceMoves(selectedSquare);
  boardUI.showPieces();
}



public SoundFile  moveSound;
public SoundFile captureSound;
public SoundFile checkSound;
public SoundFile checkMateSound;

public void initializeSound(){
  moveSound = new SoundFile(this,"move.mp3");

  checkMateSound = new SoundFile(this,"gameEnd.mp3");
  
}
class Board {
  int[] squares = new int[64];

  boolean whiteTurn = true;
  int colorToMove = white;
  //1 is white 0 is black.
  int colorIndex;
  int opponent;
  int[] kingSquares = new int[2];


  int lightColor = color(50, 205, 203);
  int darkColor  = color(205, 50, 52);
  boolean promotedLastMove = false;

  boolean whiteCastled=false;
  boolean blackCastled = false;

  public PieceList[] rooks;
  public PieceList[] bishops;
  public PieceList[] queens;
  public PieceList[] knights;
  public PieceList[] pawns;

  PieceList[] allPieceLists;


  /*bits : 0-3 -> en passant file
   4-8 -> captured Piece
   9-12 -> castling legalities.
   
   */
  Stack<Integer> gameStateHistory = new Stack();
  int gameState = 0b000000001111;


  //fens of previous positions.
  String fenString;
  Stack<String> repetitionHistory = new Stack();
  
  //5.5 means 5 moves and white made a move.increment by 0.5 each move.
  float fiftyMoveCount=0;
  Stack<Float> fiftyMoveHistory = new Stack();

  boolean draw;


  //this works after bitwise shift to as left as possible
  int capPieceMask = 0b11111;
  int epFileMask = 0b1111;
  int castlingMask = 0b1111;

  int plyCount = 1;

  public PieceList getPieceList(int pieceType, int c) {
    return allPieceLists[c*8 + pieceType];
  }

  public void makeMove(Move move) {
    int startSquare=move.startSquare;
    int targetSquare=move.endSquare;
    int capturedPiece=squares[targetSquare];
    int pieceType = pieceType(squares[startSquare]);
    int capPieceType = pieceType(capturedPiece);

    int newCastleState = gameState & castlingMask;
    boolean isPromotion = move.isPromotion();
    PVector startPosition = indexToCoord(startSquare);
    PVector targetPosition = indexToCoord(targetSquare);

    gameState = 0;
    gameState |= capturedPiece<<4;

    squares[targetSquare] = squares[startSquare];
    
    fiftyMoveCount += 0.5f;
    if (pieceType == king) {
      kingSquares[PApplet.parseInt(whiteTurn)] = targetSquare;
      newCastleState &= (colorToMove == white)? 0b1100:0b0011;
    } else
      getPieceList(pieceType, PApplet.parseInt(whiteTurn)).move(startSquare, targetSquare);


    if (pieceType==rook)
    {
      if (startPosition.x == 7)
        newCastleState &= colorToMove==white?0b1110:0b1011;
      else if (startPosition.x == 0)
        newCastleState &= colorToMove==white?0b1101:0b0111;
    } else if (pieceType(capturedPiece) == rook) {
      if (targetPosition.x == 7)
        newCastleState &= colorToMove==black?0b1110:0b1011;
      else if (targetPosition.x == 0)
        newCastleState &= colorToMove==black?0b1101:0b0111;
    }
    
    if(pieceType == pawn) fiftyMoveCount = 0;


    if (capturedPiece != empty && !(move.flag == Move.Flag.isEnPassant)) {
      fiftyMoveCount = 0;
      getPieceList(capPieceType, PApplet.parseInt(!whiteTurn)).removePiece(targetSquare);
    }
    if (isPromotion) {
      int promotionType = move.promotionPiece();

      getPieceList(promotionType, colorIndex).addPiece(targetSquare);
      squares[targetSquare] = colorToMove | promotionType;
      pawns[PApplet.parseInt(whiteTurn)].removePiece(targetSquare);
    } else {
      int epSquare = targetSquare + ((colorToMove == white) ? 8 : -8);
      switch(move.flag) {
      case Move.Flag.isEnPassant:
        gameState |= squares[epSquare]<<4;
        pawns[PApplet.parseInt(!whiteTurn)].removePiece(epSquare);
        squares[epSquare] = 0;
        break;
      case Move.Flag.pawnTwoForward:
        gameState |= ((int)targetPosition.x+1)<<9;
        break;
      case Move.Flag.castling:
        boolean kingSide = targetPosition.x==6 ? true:false;
        int rookMoveFrom = kingSide ? targetSquare+1 : targetSquare-2;
        int rookMoveTo = kingSide ? targetSquare-1:targetSquare+1;

        if (colorToMove==white)whiteCastled = true;
        else blackCastled = true;

        squares[rookMoveTo] = squares[rookMoveFrom];
        squares[rookMoveFrom] = empty;

        rooks[colorIndex].move(rookMoveFrom, rookMoveTo);
        newCastleState &= colorToMove==white?0b1100:0b0011;
      }
    }
    gameState |= newCastleState;
    squares[startSquare] = empty;
    gameStateHistory.push(gameState);
    
    fenString = board.toString();
    repetitionHistory.push(fenString);
    fiftyMoveHistory.push(fiftyMoveCount);
    draw = isDraw();
    whiteTurn = !whiteTurn;
    colorIndex = PApplet.parseInt(whiteTurn);
    if (whiteTurn) {
      colorToMove = white;
      opponent = black;
    } else {
      colorToMove = black;
      opponent = white;
    }
    plyCount++;

    //printGameState();
  }


  public void unMakeMove(Move move) {
    int startSquare=move.startSquare;
    int targetSquare=move.endSquare;
    int pieceType = pieceType(squares[targetSquare]);
    int capturedPiece=(gameState>>4)&capPieceMask;
    int capPieceType = pieceType(capturedPiece);

    boolean isPromotion = move.isPromotion();
    PVector targetPosition = indexToCoord(targetSquare);

    whiteTurn = !whiteTurn;
    colorIndex = PApplet.parseInt(whiteTurn);

    if (whiteTurn) {
      colorToMove = white;
      opponent = black;
    } else {
      colorToMove = black;
      opponent = white;
    }
    plyCount--;

    squares[startSquare] = squares[targetSquare];
    squares[targetSquare] = 0;
    if (capturedPiece != empty && move.flag != Move.Flag.isEnPassant) {
      squares[targetSquare] = capturedPiece;
      getPieceList(capPieceType, PApplet.parseInt(!whiteTurn)).addPiece(targetSquare);
    }

    if (pieceType == king)
      kingSquares[PApplet.parseInt(whiteTurn)] = startSquare;
    else if (!isPromotion) {
      getPieceList(pieceType, PApplet.parseInt(whiteTurn)).move(targetSquare, startSquare);
    }
    if (isPromotion) {
      squares[startSquare] = colorToMove | pawn;
      pawns[colorIndex].addPiece(startSquare);

      int promotionType = move.promotionPiece();

      getPieceList(promotionType, colorIndex).removePiece(targetSquare);
    } else {
      int epSquare = targetSquare + ((colorToMove == black) ? -8 : 8);

      switch(move.flag) {
      case Move.Flag.isEnPassant:
        squares[epSquare] = capturedPiece;
        squares[targetSquare] = empty;
        pawns[PApplet.parseInt(!whiteTurn)].addPiece(epSquare);

        break;

      case Move.Flag.castling:
        boolean kingSide = targetPosition.x==6 ? true:false;
        int rookMoveFrom = kingSide ? targetSquare+1 : targetSquare-2;
        int rookMoveTo = kingSide ? targetSquare-1:targetSquare+1;
        if (colorToMove==white)whiteCastled = false;
        else blackCastled = false;

        squares[rookMoveFrom] = squares[rookMoveTo];
        squares[rookMoveTo] = 0;
        rooks[colorIndex].move(rookMoveTo, rookMoveFrom);
      }
    }
    gameStateHistory.pop();
    gameState=gameStateHistory.peek();
    repetitionHistory.pop();
    fenString = repetitionHistory.peek();
    fiftyMoveHistory.pop();
    fiftyMoveCount=fiftyMoveHistory.peek();
    draw = isDraw();
  }

  //piece fen notation.
  char[] pieceName
    = new char []{
    '.',
    '.',
    '.',
    '.',
    '.',
    '.',
    '.',
    '.',
    '.',
    'K',
    'P',
    'N',
    '.',
    'B',
    'R',
    'Q',
    '.',
    'k',
    'p',
    'n',
    '.',
    'b',
    'r',
    'q'
  };

  public String toString() {
    String fen = "";
    for (int rank = 0; rank<8; rank++) {
      for (int file = 0; file<8; file++) {
        char c = pieceName[squares[file+rank*8]];
        fen+=c;
      }
      fen+="/";
    }

    fen += gameState&castlingMask;
    return fen;
  }
  public boolean isDraw() {
    int count = 0;
    for (String fen : repetitionHistory) {
      if (fen.equals(fenString)) {
        count++;
      }
    }

    return (count >= 3) || (fiftyMoveCount >= 50);
  }
  public void switchSides() {
    whiteTurn = !whiteTurn;
    colorIndex = PApplet.parseInt(whiteTurn);
    if (whiteTurn) {
      colorToMove = white;
      opponent = black;
    } else {
      colorToMove = black;
      opponent = white;
    }
  }
  public void init() {
    gameState = 0b000000001111;
    gameStateHistory = new Stack();
    gameStateHistory.push(gameState);
    fenString = toString();
    repetitionHistory = new Stack();
    repetitionHistory.push(fenString);
    fiftyMoveCount = 0;
    fiftyMoveHistory = new Stack();
    fiftyMoveHistory.push(fiftyMoveCount);
    whiteTurn = true;
    colorToMove =white;
    opponent = black;
    plyCount = 0;

    knights = new PieceList[]{new PieceList(), new PieceList()};
    bishops = new PieceList[]{new PieceList(), new PieceList()};
    rooks = new PieceList[]{new PieceList(), new PieceList()};
    queens = new PieceList[]{new PieceList(), new PieceList()};
    pawns = new PieceList[]{new PieceList(), new PieceList()};
    PieceList empties = new PieceList();
    allPieceLists = new PieceList[]{
      empties,
      empties,
      pawns[0],
      knights[0],
      empties,
      bishops[0],
      rooks[0],
      queens[0],
      empties,
      empties,
      pawns[1],
      knights[1],
      empties,
      bishops[1],
      rooks[1],
      queens[1],
    };
  }

  public int getPieceCount() {
    return knights[0].numPieces+bishops[0].numPieces+rooks[0].numPieces+queens[0].numPieces
      +knights[1].numPieces+bishops[1].numPieces+rooks[1].numPieces+queens[1].numPieces;
  }

  public void printGameState() {
    println("Move : " + plyCount/2 + "\n Ply : " + plyCount
      + "\n En Passant File : " + (gameState>>9)
      + "\n En Passant Rank : " + (colorToMove==white?5:1)
      + "\n Captured Piece : " + Integer.toBinaryString((gameState<<4 & capPieceMask))
      + "\n Castle Rights : " + Integer.toBinaryString((gameState & castlingMask))
      + "\n Entire Game State: " + Integer.toBinaryString(gameState)
      + "\n Color To Move : " + (colorToMove == white ? "White" : "Black")
      + "\n White King Square : " + kingSquares[1]
      + "\n Black King Square : " + kingSquares[0]
      + "\n Fifty Move Counter: " + (int)fiftyMoveCount
      + "\n");
  }
}
class BoardUI
{

  PVector pos;
  float dim;

  int lightColor = color(0xFF34CBAE);
  int darkColor = color(0xFFCB3451);

  Board displayBoard;
  Move playedMove;




  int animationProgress = 100;
  boolean animationDone = true;
  float animationEasing = 0.25f;

  BoardUI(Board b, PVector position, float dimensions, int lc, int dc) {
    displayBoard = b;
    pos = position;
    dim = dimensions;
    lightColor = lc;
    darkColor = dc;
  }

  //MUST BE CALLED BEFORE MAKING THE MOVE ON BOARD !!!!!
  public void playMove(Move move) {
    playedMove = move;
    playSounds(move);
    animationDone = false;
    animationProgress = 0;
  }
  public void showSquares() {
    noStroke();
    fill(255);
    for (int file = 0; file<8; file++) {
      for (int rank = 0; rank<8; rank++) {
        if ((file+rank)%2 == 0) fill(lightColor);
        else fill(darkColor);

        square(file*s, rank*s, s);

        fill(0);
        //text(file+rank*8, file*s + 5, rank*s+s-5);
      }
    }
    if (playedMove!=null) {
      fill(0xFF0FF080);
      square(file(playedMove.startSquare)*s, rank(playedMove.startSquare)*s, s);
      fill(0xFF28D75D);
      square(file(playedMove.endSquare)*s, rank(playedMove.endSquare)*s, s);
    }
    fill(255);
  }
  public void showPieces() {
    noStroke();
    boolean isAnimationPiece = false;
    for (int file = 0; file<8; file++) {
      for (int rank = 0; rank<8; rank++) {
        isAnimationPiece = playedMove != null && file+rank*8==playedMove.endSquare && !animationDone;
        if (!isAnimationPiece) {

          int piece = board.squares[getIndex(file, rank)];
          image(getPieceImage(piece), file*s, rank*s, s, s);
        }
      }
    }
    if (!animationDone) {

      animationProgress += (110-animationProgress)*animationEasing;
      animationProgress = min(100, animationProgress);
      animationDone = animationProgress>=100;

      float movedX = map(animationProgress, 0, 100, file(playedMove.startSquare), file(playedMove.endSquare));
      float movedY = map(animationProgress, 0, 100, rank(playedMove.startSquare), rank(playedMove.endSquare));
      int piece = board.squares[playedMove.endSquare];
      image(getPieceImage(piece), movedX*s, movedY*s, s, s);
    }
  }
  public void showGameOverText() {
    fill(0, 150);
    rect(0, 0, width, height);
    textAlign(CENTER, CENTER);
    fill(255);
    textSize(100);
    text(gameOverText, width/2, height/2);
  }
  public void playSounds(Move move) {

    board.makeMove(move);
    moveGenerator.generateLegalMoves(board);
    if (checkGameOver()) {
      checkMateSound.play();
      board.unMakeMove(move);
      return;
    }
    board.unMakeMove(move);

    moveSound.play();
  }

  public void animate() {
  }
}

final int PAWNVAL = 100;
final int KNIGHTVAL = 300;
final int BISHOPVAL = 320;
final int ROOKVAL = 500;
final int QUEENVAL = 900;

final int FIANCHETTOBONUS=50;

final int BISHOPPAIRBONUS=50;

final int CASTLEBONUS=100;
final int CASTLERIGHTBONUS=50;



final int DEVELOPMENTBONUS = 50;

PVector center = new PVector(4, 4);

int endGameMaterial = ROOKVAL * 2 + BISHOPVAL + KNIGHTVAL;
public int evaluate() {

  boolean endGame = false;

  if (board.getPieceCount() < 4) endGame = true;
  int whiteEval = countMaterial(1, endGame);
  int blackEval = countMaterial(0, endGame);


  float whiteEndgameWeight = endGamePower(whiteEval-board.pawns[1].numPieces*PAWNVAL);
  float blackEndgameWeight =endGamePower(blackEval-board.pawns[0].numPieces*PAWNVAL);

  whiteEval+=sweep(1, 0, whiteEval, blackEval, whiteEndgameWeight);
  blackEval+=sweep(0, 1, blackEval, whiteEval, blackEndgameWeight);

  int evaluation = whiteEval-blackEval;


  int perspective = board.colorToMove == white? 1:-1;

  return evaluation*perspective;
}

//Force king to corner.
public int sweep(int myIndex, int opponentIndex, int myMat, int opponentMat, float endGameWeight) {
  if (myMat>opponentMat) {
    int friendlyKingSquare = board.kingSquares[myIndex];
    int opponentKingSquare = board.kingSquares[opponentIndex];

    return forceKingToCornerEval(friendlyKingSquare, opponentKingSquare, endGameWeight);
  }
  return 0;
}
public int countMaterial(int colorIndex, boolean endGame) {
  int material = 0;
  int colorToEval = colorIndex ==  0 ?black:white;
  for (int i = 0; i<64; i++) {
    if (getColor(board.squares[i]) == colorToEval) {
      int pieceType = pieceType(board.squares[i]);
      if (pieceType == pawn) {
        material += PAWNVAL + PAWN_VALUES[PApplet.parseInt(endGame)][colorIndex][i];
      } else if (pieceType == knight)
        material += KNIGHT_VALUES[PApplet.parseInt(endGame)][colorIndex][i];
      else if (pieceType == bishop)
        material += BISHOP_VALUES[PApplet.parseInt(endGame)][colorIndex][i];
      else if (pieceType == rook)
        material += ROOKVAL;
      else if (pieceType == queen)
        material +=  QUEENVAL;
      else if (pieceType == king) {
        material+=getKingValue( endGame, colorToEval);
      }
    }
  }
  return material; 
}


public float endGamePower(int materialWithoutPawns) {
  float mult = 1/endGameMaterial;
  return 1 - min(1, materialWithoutPawns*mult);
}



//multiply this with total material.
public int getKingValue(boolean endGame, int colorToMove) {
  int value = 0;

  if (!endGame) {


    if (colorToMove == white) {
      if ((board.gameState&0b0011) == 0 && !board.whiteCastled) value -= CASTLERIGHTBONUS;
      else if (board.whiteCastled)value += CASTLEBONUS;
    } else if (colorToMove == black) {
      if ((board.gameState&0b1100) == 0 && !board.whiteCastled)value -= CASTLERIGHTBONUS;
      else if (board.blackCastled)value += CASTLEBONUS;
    }
  }
  return value;
}

public int forceKingToCornerEval(int myKingSquare, int opponentKingSquare, float endGameWeight) {
  int evaluation = 0;

  int opponentRank = rank(opponentKingSquare);
  int opponentFile = file(opponentKingSquare);

  int opponentKingDistFromCenterFile = max(3-opponentFile, opponentFile-4);
  int opponentKingDistFromCenterRank = max(3-opponentRank, opponentRank-4);
  int opponentKingDistFromCenter = opponentKingDistFromCenterFile+opponentKingDistFromCenterRank;
  evaluation += opponentKingDistFromCenter;

  int myKingRank = rank(myKingSquare);
  int myKingFile = file(myKingSquare);

  int distBetweenKingsFile = abs(myKingFile-opponentFile);
  int distBetweenKingsRank = abs(myKingRank-opponentRank);

  int distBetweenKings = distBetweenKingsFile+distBetweenKingsRank;

  evaluation += 14-distBetweenKings;
  return (int)(evaluation*10 * endGameWeight);
}
public Board fenToBoard(String fenString) {
  Board board = new Board();
  board.init();

  char[] chars = fenString.toCharArray();

  int file = 0;
  int rank = 0;
  boolean detectCastling = false;
  boolean whiteTurn = true;
  int colorToMove = white;
  int opponent = black;

  int gameState = 0;
  for (int i = 0; i<chars.length; i++) {
    char c = chars[i];

    if (c == ' ')
      detectCastling = true;
    if (!detectCastling) {
      if (Character.isDigit(c)) {
        file += Character.getNumericValue(c);
      } else if (c == '/') {
        rank++;
        file=0;
      } else {

        char lc = Character.toLowerCase(c);

        int sq = board.squares[file + rank*8];
        boolean whitePiece = Character.isUpperCase(c);
        if (lc == 'k')
          sq = king;
        else if (lc == 'p')
          sq = pawn;
        else if (lc == 'n')
          sq = knight;
        else if (lc == 'b')
          sq = bishop;
        else if (lc == 'r')
          sq = rook;
        else if (lc == 'q')
          sq = queen;
        board.getPieceList(sq, PApplet.parseInt(whitePiece)).addPiece(file+rank*8);

        if (whitePiece) {
          if (lc == 'k')board.kingSquares[1] = file+rank*8;
          sq |= white;
        } else
        {
          if (lc == 'k')board.kingSquares[0] = file+rank*8;
          sq |= black;
        }
        board.squares[file + rank*8] = sq;
        file += 1;
      }
    } else {
      if (c=='w') {
        whiteTurn = true;
        colorToMove = white;
        opponent = black;
      } else if (c=='b') {
        whiteTurn = false;
        colorToMove = black;
        opponent = white;
      } else if (c == 'K')gameState |= 0b0001;
      else if (c=='Q')gameState |= 0b0010;
      else if (c=='k')gameState |= 0b0100;
      else if (c=='q')gameState |= 0b1000;
    }
  }
  board.gameState = gameState;
  board.whiteTurn = whiteTurn;
  board.colorToMove = colorToMove;
  board.opponent = opponent;
  return board;
}
class KetchupCrewV2 {

  class Result {
    int score;
    Move move;

    Result(int score, Move move) {
      this.score = score;
      this.move = move;
    }
  }
  public Result search(int depth, Move bestMove, int alpha, int beta) {
    if (depth == 0) {
      return new Result(evaluate(), bestMove);
    }

    ArrayList<Move> moves = moveGenerator.generateLegalMoves(board);

    if (moves.size() == 0) {
      if (moveGenerator.inCheck())
        return new Result(-LARGENUMBER, bestMove);
      else return new Result(0, bestMove);
    } else if (board.draw) {
      return new Result(0, bestMove);
    }

    int bestScore = -LARGENUMBER;

    for (Move move : moves) {
      board.makeMove(move);
      int eval = -search(depth - 1, move, -beta, -alpha).score;
      board.unMakeMove(move);

      if (eval >= bestScore) {
        bestScore = eval;
        bestMove = move;
      }

      alpha = Math.max(alpha, eval);
      if (alpha >= beta) break;  // beta cut-off
    }

    return new Result(bestScore, bestMove);
  }
}
class Move {

  class Flag {
    public static final int none = 0;
    public static final int isEnPassant = 1;
    public static final int castling = 2;
    public static final int promoteToQueen = 3;
    public static final int promoteToKnight = 4;
    public static final int promoteToRook = 5;
    public static final int promoteToBishop = 6;
    public static final int pawnTwoForward = 7;
  }

  int startSquare;
  int endSquare;
  int flag;

  Move(int startSquare, int endSquare, int flag) {
    this.startSquare = startSquare;
    this.endSquare   = endSquare;
    this.flag        = flag;
  }

  public boolean isPromotion() {
    if (flag == Flag.promoteToQueen
      || flag == Flag.promoteToKnight
      || flag == Flag.promoteToRook
      || flag == Flag.promoteToBishop
      )
    {
      return true;
    }

    return false;
  }
  public int promotionPiece() {
    switch(flag) {
    case Flag.promoteToQueen:
      return queen;
    case Flag.promoteToKnight:
      return knight;
    case Flag.promoteToRook:
      return rook;
    case Flag.promoteToBishop:
      return bishop;
    default:
      return 0;
    }
  }
}
class MoveGenerator {

  Board board;
  ArrayList<Move> moves;

  int friendlyKingSquare;
  int opponentKingSquare;
  int friendlyColorIndex;
  int opponentColorIndex;

  int f1 = 61;
  int f8 = 5;
  int d1 = 59;
  int d8 = 3;


  public void init() {
    moves = new ArrayList<Move>();

    friendlyColorIndex = PApplet.parseInt(board.whiteTurn);
    opponentColorIndex = PApplet.parseInt(!board.whiteTurn);

    friendlyKingSquare = board.kingSquares[friendlyColorIndex];
    opponentKingSquare = board.kingSquares[opponentColorIndex];
  }
  public ArrayList<Move> generateMoves(Board _board) {
    board = _board;
    init();

    generateKingMoves();
    generatePawnMoves();
    generateSlidingMoves();
    generateKnightMoves();

    return moves;
  }


  public boolean inCheck() {
    ArrayList<Move> moves = generateOpponentLegalMoves(board);
    int kingSquare=board.kingSquares[PApplet.parseInt(board.whiteTurn)];
    for (Move move : moves) {
      if (move.endSquare==kingSquare)return true;
    }
    return false;
  }
  public ArrayList<Move> generateLegalMoves(Board _board) {
    this.board = _board;
    ArrayList<Move> pseudoLegalMoves = generateMoves(this.board);
    ArrayList<Move> legalMoves = new ArrayList<Move>();
    for (Move move : pseudoLegalMoves) {
      this.board.makeMove(move);
      int myKingSquare = board.kingSquares[PApplet.parseInt(!board.whiteTurn)];
      boolean castle = move.flag == Move.Flag.castling;
      ArrayList<Move> responses = generateMoves(this.board);

      boolean illegal = false;

      for (int i = 0; i<responses.size(); i++) {
        if (responses.get(i).endSquare == myKingSquare
          ||(castle && (responses.get(i).endSquare==move.startSquare+(move.endSquare-move.startSquare )
          || responses.get(i).endSquare==move.startSquare))) {
          illegal = true;
        }
      }

      if (!illegal) {
        legalMoves.add(move);
      }

      this.board.unMakeMove(move);
    }
    moves = legalMoves;
    return legalMoves;
  }
  public ArrayList<Move> generateOpponentLegalMoves(Board _board) {
    this.board = _board;
    _board.switchSides();
    ArrayList<Move> legalMoves = generateLegalMoves(board);
    _board.switchSides();
    moves = legalMoves;
    return legalMoves;
  }
  public void generateSlidingMoves() {
    PieceList rooks = board.rooks[friendlyColorIndex];
    for (int i = 0; i<rooks.numPieces; i++)
      generateSlidingPieceMoves(rooks.occupiedSquares[i], rook);

    PieceList bishops = board.bishops[friendlyColorIndex];
    for (int i = 0; i<bishops.numPieces; i++)
      generateSlidingPieceMoves(bishops.occupiedSquares[i], bishop);

    PieceList queens = board.queens[friendlyColorIndex];
    for (int i = 0; i<queens.numPieces; i++)
      generateSlidingPieceMoves(queens.occupiedSquares[i], queen);
  }

  public void generateSlidingPieceMoves(int startSquare, int piece) {

    int startDirIndex = piece == bishop ? 4 : 0;
    int endDirIndex   = piece == rook ? 4 : 8;


    for (int dirIndex = startDirIndex; dirIndex < endDirIndex; dirIndex++) {
      int dirOffset = directionOffsets[dirIndex];
      for (int n = 0; n<distToEdge[startSquare][dirIndex]; n++) {

        int targetSquare = startSquare + (n+1) * dirOffset;
        if (this.board.squares[targetSquare] != 0) {
          if (isColor(this.board.squares[targetSquare], this.board.whiteTurn))
            break;
          else {
            moves.add(new Move(startSquare, targetSquare, Move.Flag.none));
            break;
          }
        }
        moves.add(new Move(startSquare, targetSquare, Move.Flag.none));
      }
    }
  }

  public void generatePawnMoves() {
    PieceList pawns = board.pawns[friendlyColorIndex];
    int col = this.board.colorToMove;
    int turnVal = PApplet.parseInt(this.board.whiteTurn);
    int forward = 8;
    int enPassantFile = (board.gameState>>9)-1;
    int enPassantSquare = -1;

    if (enPassantFile != -1)
      enPassantSquare = enPassantFile + (col == white?2:5)*8;

    if (col==white) forward *= -1;
    for (int i = 0; i<pawns.numPieces; i++) {
      int startSquare = pawns.occupiedSquares[i];
      boolean isPromotionStep
        = rank(startSquare+forward) == 7 || rank(startSquare+forward) == 0;

      if (this.board.squares[startSquare+forward] == 0) {
        if (!isPromotionStep)moves.add(new Move(startSquare, startSquare+forward, Move.Flag.none));
        else addPromotionMoves(startSquare, startSquare+forward);
        if (pawnTwoJumpSquares.get(turnVal).contains(startSquare) && this.board.squares[startSquare+forward*2] == 0)
          moves.add(new Move(startSquare, startSquare+forward*2, Move.Flag.pawnTwoForward));
      }
      for (int j = 0; j<pawnCaptures[turnVal][startSquare].length; j++) {
        if (this.board.squares[pawnCaptures[turnVal][startSquare][j]] != 0
          && !isColor(this.board.squares[pawnCaptures[turnVal][startSquare][j]], this.board.whiteTurn)) {
          if (!isPromotionStep)
            moves.add(new Move(startSquare, pawnCaptures[turnVal][startSquare][j], Move.Flag.none));
          else
            addPromotionMoves(startSquare, pawnCaptures[turnVal][startSquare][j]);
        } else if (pawnCaptures[turnVal][startSquare][j] == enPassantSquare)
          moves.add(new Move(startSquare, pawnCaptures[turnVal][startSquare][j], Move.Flag.isEnPassant));
      }
    }
  }

  public void generateKnightMoves() {
    PieceList knights = board.knights[friendlyColorIndex];
    for (int i = 0; i<knights.numPieces; i++) {
      int startSquare = knights.occupiedSquares[i];
      int[] nMoves = knightMoves[startSquare];
      for (int j = 0; j<nMoves.length; j++) {
        if (!(this.board.squares[nMoves[j]] != empty && isColor(this.board.squares[nMoves[j]], this.board.whiteTurn)))moves.add(new Move(startSquare, nMoves[j], Move.Flag.none));
      }
    }
  }

  public void generateKingMoves() {
    for (int i = 0; i<kingMoves[friendlyKingSquare].length; i++) {
      int endSquare = kingMoves[friendlyKingSquare][i];
      //println(manhattanDistance(startSquare,endSquare));
      if (!isColor(this.board.squares[endSquare], this.board.whiteTurn))
        moves.add(new Move(friendlyKingSquare, endSquare, Move.Flag.none));

      if ((endSquare == f1 || endSquare == f8) && hasKingsideCastleRight()) {
        int castledSquare = endSquare+1;
        if (board.squares[endSquare] == empty && board.squares[castledSquare] == empty) {
          moves.add(new Move(friendlyKingSquare, castledSquare, Move.Flag.castling));
        }
      } else if ((endSquare == d1 || endSquare == d8) && hasQueensideCastleRight()) {
        int castledSquare = endSquare-1;
        if (board.squares[endSquare] == empty && board.squares[castledSquare] == empty && board.squares[castledSquare-1] == empty) {
          moves.add(new Move(friendlyKingSquare, castledSquare, Move.Flag.castling));
        }
      }
    }
  }


  public boolean hasKingsideCastleRight() {
    int mask = board.whiteTurn ? 0b0001 : 0b0100;
    return (board.gameState & mask) != 0;
  }
  public boolean hasQueensideCastleRight() {
    int mask = board.whiteTurn ? 0b0010 : 0b1000;
    return (board.gameState & mask) != 0;
  }

  public void addPromotionMoves(int startSquare, int endSquare) {
    moves.add(new Move(startSquare, endSquare, Move.Flag.promoteToQueen));
    moves.add(new Move(startSquare, endSquare, Move.Flag.promoteToKnight));
    moves.add(new Move(startSquare, endSquare, Move.Flag.promoteToRook));
    moves.add(new Move(startSquare, endSquare, Move.Flag.promoteToBishop));
  }
  public void showAllMoves() {

    for (int i = 0; i<moves.size(); i++) {
      PVector startPos = indexToCoord(moves.get(i).startSquare);
      PVector endPos = indexToCoord(moves.get(i).endSquare);
      fill(186, 202, 68);
      square(startPos.x*s, startPos.y*s, s);
      fill(0, 100);
      circle(endPos.x*s + s/2, endPos.y*s + s/2, s/2);
    }
  }
  public void showPieceMoves(int startSquare) {

    PVector startPos = indexToCoord(startSquare);
    fill(186, 202, 68);
    square(startPos.x*s, startPos.y*s, s);

    for (int i = 0; i<moves.size(); i++) {
      if (moves.get(i).startSquare != startSquare) continue;
      PVector endPos = indexToCoord(moves.get(i).endSquare);
      fill(0, 100);
      square(endPos.x*s, endPos.y*s, s);
    }
  }
}
static final int white = 8;
static final int black = 16;

static final int empty = 0;
static final int king = 1;
static final int pawn = 2;
static final int knight = 3;
static final int bishop = 5;
static final int rook = 6;
static final int queen = 7;

static final int whiteKing = king | white;
static final int whitePawn = pawn | white;
static final int whiteKnight = knight | white;
static final int whiteBishop = bishop | white;
static final int whiteRook = rook | white;
static final int whiteQueen = queen | white;

static final int blackKing = king | black;
static final int blackPawn = pawn | black;
static final int blackKnight = knight | black;
static final int blackBishop = bishop | black;
static final int blackRook = rook | black;
static final int blackQueen = queen | black;

static PImage[] pieceImages = new PImage[13];


final int typeMask = 0b00111;
final int blackMask = 0b10000;
final int whiteMask = 0b01000;
final int colourMask = whiteMask | blackMask;

public void setupImages() {
  pieceImages[0] = createImage(0, 0, RGB);
  pieceImages[1] = loadImage("whiteKing.png");
  pieceImages[2] = loadImage("whitePawn.png");
  pieceImages[3] = loadImage("whiteKnight.png");
  pieceImages[4] = loadImage("whiteBishop.png");
  pieceImages[5] = loadImage("whiteRook.png");
  pieceImages[6] = loadImage("whiteQueen.png");
  pieceImages[7] = loadImage("blackKing.png");
  pieceImages[8] = loadImage("blackPawn.png");
  pieceImages[9] = loadImage("blackKnight.png");
  pieceImages[10] = loadImage("blackBishop.png");
  pieceImages[11] = loadImage("blackRook.png");
  pieceImages[12] = loadImage("blackQueen.png");
}

public boolean isColor(int piece, boolean whiteTurn) {
  if(getColor(piece) == white && whiteTurn) return true;
  else if(getColor(piece) == black && !whiteTurn) return true;
  return false;
}

public int getColor(int piece){ return piece & colourMask;}


public int pieceType(int piece){ return piece & typeMask;}

public boolean isSliding(int piece){return (piece & 0b100) != 0;}

public boolean isRookOrQueen(int piece){return (piece & 0b110) == 0b110;}
public boolean isBishopOrQueen(int piece){return (piece & 0b101) == 0b101;}
//Index offsets for all 8 directions.
int[] directionOffsets = {8, -8, 1, -1, 7, -7, 9, -9};


//index offsets for knights.
int[] knightMoveOffsets = { 15, 17, -17, -15, 10, -6, 6, -10};


//Cartesian offsets for knights.
int[] knightMoveXOffsets = {-1, 1, -1, 1, 2, 2, -2, -2};
int[] knightMoveYOffsets = {2, 2, -2, -2, 1, -1, 1, -1};

//[][] => squares/moves.
int[][] knightMoves = new int[64][];

// [][][] => color/squares/moves.
int[][][] pawnCaptures = new int[2][64][];


//set of each squares where pawns can jump two times. first set is for black and second is for white.

ArrayList<Set<Integer>> pawnTwoJumpSquares = new ArrayList<Set<Integer>>();


int[][] kingMoves = new int[64][];

int[][] distToEdge = new int[64][];

public void computeMoveData() {

  IntList whiteJumps = new IntList();
  IntList blackJumps = new IntList();

  for (int file = 0; file < 8; file++) {

    for (int rank = 0; rank < 8; rank++) {

      int squareIndex = file + rank * 8;
      PVector position = indexToCoord(squareIndex);

      distToEdge[squareIndex] = new int[8];

      int top = 7 - rank;
      int bottom = rank;

      int right = 7 - file;
      int left = file;

      distToEdge[squareIndex][0] = top;
      distToEdge[squareIndex][1] = bottom;
      distToEdge[squareIndex][2] = right;
      distToEdge[squareIndex][3] = left;
      distToEdge[squareIndex][4] = min(left, top);
      distToEdge[squareIndex][5] = min(right, bottom);
      distToEdge[squareIndex][6] = min( right, top);
      distToEdge[squareIndex][7] = min(left, bottom);



      IntList knightSquares = new IntList();
      for (int i = 0; i<knightMoveOffsets.length; i++) {
        PVector coord = PVector.add(indexToCoord(squareIndex), new PVector(knightMoveXOffsets[i], knightMoveYOffsets[i]));
        if (coord.x >= 0 && coord.x < 8 && coord.y >= 0 && coord.y < 8) knightSquares.append(squareIndex + knightMoveOffsets[i]);
      }
      knightMoves[squareIndex] = knightSquares.toArray();


      IntList sqWhitePawnCaptures = new IntList();

      if (file != 7)sqWhitePawnCaptures.append(squareIndex - 7);
      if (file != 0)sqWhitePawnCaptures.append(squareIndex - 9);

      pawnCaptures[1][squareIndex] = sqWhitePawnCaptures.toArray();

      IntList sqBlackPawnCaptures = new IntList();
      position = indexToCoord(squareIndex);
      if (file != 0)sqBlackPawnCaptures.append(squareIndex + 7);
      if (file != 7)sqBlackPawnCaptures.append(squareIndex + 9);

      pawnCaptures[0][squareIndex] = sqBlackPawnCaptures.toArray();

      if (rank == 1)
        blackJumps.append(squareIndex);
      else if (rank == 6)
        whiteJumps.append(squareIndex);

      IntList sqKingMoves = new IntList();

      for (int i = 0; i<directionOffsets.length; i++) {
        if (!outsideBoard(squareIndex + directionOffsets[i]) && manhattanDistance(squareIndex, indexToCoord(squareIndex + directionOffsets[i])) <= 2)
          sqKingMoves.append(squareIndex + directionOffsets[i]);
      }
      kingMoves[squareIndex] = sqKingMoves.toArray();
    }
  }
  HashSet blackSet = new HashSet<>(Arrays.stream(blackJumps.toArray()).boxed().collect(Collectors.toSet()));
  HashSet whiteSet = new HashSet<>(Arrays.stream(whiteJumps.toArray()).boxed().collect(Collectors.toSet()));
  pawnTwoJumpSquares.add(blackSet);
  pawnTwoJumpSquares.add(whiteSet);
}
public int getIndex(int x, int y) {
  return x+y*8;
}

public PImage getPieceImage(int i) {
  int offset = 0;
  if (i > 16)offset=6;

  int x = 7 & i;

  if (x == 0) return pieceImages[0];
  if (x == 1) return pieceImages[1+offset];
  if (x == 2) return pieceImages[2+offset];
  if (x == 3) return pieceImages[3+offset];
  if (x == 5) return pieceImages[4+offset];
  if (x == 6) return pieceImages[5+offset];
  if (x == 7) return pieceImages[6+offset];

  return pieceImages[0];
}

public void deSelectPiece() {
  selectedSquare = -1000;
  tgtSquare = -1000;
}
public PVector indexToCoord(int i) {
  int y = i/8;
  int x = i%8;

  return new PVector(x, y);
}

public int rank(int square)
{
  return square/8;
}

public int file(int square) {
  return square%8;
}


public boolean selectedIsLegal(Move move) {
  for (int i = 0; i<moveGenerator.moves.size(); i++) {
    if (move.startSquare == moveGenerator.moves.get(i).startSquare &&  move.endSquare == moveGenerator.moves.get(i).endSquare)
      return true;
  }
  return false;
}
public boolean selectedIsLegal(int startSquare, int endSquare) {
  for (int i = 0; i<moveGenerator.moves.size(); i++) {
    if (startSquare == moveGenerator.moves.get(i).startSquare &&  endSquare == moveGenerator.moves.get(i).endSquare)
      return true;
  }
  return false;
}

public Move getMoveWithCoord(int start, int end) {
  try {
    return moveGenerator.moves
      .stream()
      .filter(x -> x.startSquare == start && x.endSquare == end)
      .findFirst()
      .get();
  }
  catch(Exception e) {
    return null;
  }
}

public boolean outsideBoard(int square) {
  if (square < 0)return true;
  else if (square > 63)return true;
  else return false;
}

public float manhattanDistance(int startSquare, int endSquare) {
  int startFile = file(startSquare);
  int startRank = rank(startSquare);

  int endFile = file(endSquare);
  int endRank = rank(endSquare);


  return abs(startFile-endFile)-abs(startRank-endRank);
}
 public float manhattanDistance(int startSquare, PVector center) {
  int startFile = file(startSquare);
  int startRank = rank(startSquare);


  return abs(startFile-center.x)-abs(startRank-center.y);
}
public class KetchupCrewV1 {



  public int moveGenerationTest(int depth) {
    if (depth == 0) {
      return 1;
    }

    ArrayList<Move> moves = moveGenerator.generateLegalMoves(board);
    int numPositions = 0;
    for (Move move : moves) {
      board.makeMove(move);
      numPositions += moveGenerationTest(depth-1);
      board.unMakeMove(move);
    }
    return numPositions;
  }
  class Result {
    int score;
    Move move;

    Result(int score, Move move) {
      this.score = score;
      this.move = move;
    }
  }
  public Result search(int depth, Move bestMove) {
    if (depth == 0) {
      return new Result(evaluate(), bestMove);
    }

    ArrayList<Move> moves = moveGenerator.generateLegalMoves(board);

    if (moves.size() == 0) {
      if (moveGenerator.inCheck())
        return new Result(-LARGENUMBER, bestMove);
      else return new Result(0, bestMove);
    } else if (board.draw) {
      return new Result(0, bestMove);
    }

    int bestScore = -LARGENUMBER;

    for (Move move : moves) {
      board.makeMove(move);
      int eval = -search(depth - 1, move).score;
      board.unMakeMove(move);

      if (eval >= bestScore) {
        bestScore = eval;
        bestMove = move;
      }
    }

    return new Result(bestScore, bestMove);
  }
}
class PieceList {
  int[] occupiedSquares = new int[64];
  int[] indecies = new int[64];
  int numPieces = 0;

  PieceList() {
    occupiedSquares = new int[16];
    indecies = new int[64];
    numPieces = 0;
  }
  public void addPiece(int square) {
    occupiedSquares[numPieces] = square;
    indecies[square] = numPieces;

    numPieces++;
  }
  public void removePiece(int square) {
    int index = indecies[square];
    occupiedSquares[index] = occupiedSquares[numPieces-1];
    indecies[occupiedSquares[index]] = index;
    numPieces--;
  }
  public void move(int startSquare, int targetSquare) {
    int index = indecies[startSquare];
    occupiedSquares[index] = targetSquare;
    indecies[targetSquare] = index;
  }
}
int[][][] PAWN_VALUES = new int[][][]{
  //Opening material values for pawns based on square
  new int[][]{
    //black.
    new int[]{
      0, 0, 0, 0, 0, 0, 0, 0,
      50, 50, 50, 50, 50, 50, 50, 50,
      10, 10, 20, 30, 30, 20, 10, 10,
      5, 5, 10, 25, 25, 10, 5, 5,
      0, 0, 0, 20, 20, 0, 0, 0,
      5, -5, -10, 0, 0, -10, -5, 5,
      5, 10, 10, -20, -20, 10, 10, 5,
      0, 0, 0, 0, 0, 0, 0, 0
    },
    //white.
    new int[]{
      0, 0, 0, 0, 0, 0, 0, 0,
      5, 10, 10, -20, -20, 10, 10, 5,
      5, -5, -10, 0, 0, -10, -5, 5,
      0, 0, 0, 20, 20, 0, 0, 0,
      5, 5, 10, 25, 25, 10, 5, 5,
      10, 10, 20, 30, 30, 20, 10, 10,
      50, 50, 50, 50, 50, 50, 50, 50,
      0, 0, 0, 0, 0, 0, 0, 0
    }
  },
  //Endgame material values of pawns based on squares
  new int[][]{
    //black
    new int[]{
      0, 0, 0, 0, 0, 0, 0, 0,
      60, 60, 60, 60, 60, 60, 60, 60,
      30, 30, 40, 50, 50, 40, 30, 30,
      20, 20, 30, 40, 40, 30, 20, 20,
      10, 10, 20, 30, 30, 20, 10, 10,
      0, 0, 10, 20, 20, 10, 0, 0,
      10, 20, 20, -40, -40, 20, 20, 10,
      0, 0, 0, 0, 0, 0, 0, 0
    },
    //white
    new int[]{
      0, 0, 0, 0, 0, 0, 0, 0,
      10, 20, 20, -40, -40, 20, 20, 10,
      0, 0, 10, 20, 20, 10, 0, 0,
      10, 10, 20, 30, 30, 20, 10, 10,
      20, 20, 30, 40, 40, 30, 20, 20,
      30, 30, 40, 50, 50, 40, 30, 30,
      60, 60, 60, 60, 60, 60, 60, 60,
      0, 0, 0, 0, 0, 0, 0, 0
    }
  }
};
int[][][] KNIGHT_VALUES = new int[][][]{
  //Opening material values for knights based on square
  new int[][]{
    //black.
    new int[]{
      280, 320, 320, 320, 320, 320, 320, 280,
      320, 360, 380, 380, 380, 380, 360, 320,
      320, 380, 400, 420, 420, 400, 380, 320,
      320, 380, 420, 440, 440, 420, 380, 320,
      320, 380, 420, 440, 440, 420, 380, 320,
      320, 380, 400, 420, 420, 400, 380, 320,
      320, 360, 380, 380, 380, 380, 360, 320,
      280, 320, 320, 320, 320, 320, 320, 280
    },
    //white.
    new int[]{
      280, 320, 320, 320, 320, 320, 320, 280,
      320, 360, 380, 380, 380, 380, 360, 320,
      320, 380, 400, 420, 420, 400, 380, 320,
      320, 380, 420, 440, 440, 420, 380, 320,
      320, 380, 420, 440, 440, 420, 380, 320,
      320, 380, 400, 420, 420, 400, 380, 320,
      320, 360, 380, 380, 380, 380, 360, 320,
      280, 320, 320, 320, 320, 320, 320, 280
    }
  },
  //Endgame material values of knights based on squares
  new int[][]{
    //black
    new int[]{
      250, 270, 270, 270, 270, 270, 270, 250,
      270, 300, 320, 320, 320, 320, 300, 270,
      270, 320, 340, 350, 350, 340, 320, 270,
      270, 320, 350, 360, 360, 350, 320, 270,
      270, 320, 350, 360, 360, 350, 320, 270,
      270, 320, 340, 350, 350, 340, 320, 270,
      270, 300, 320, 320, 320, 320, 300, 270,
      250, 270, 270, 270, 270, 270, 270, 250
    },
    //white
    new int[]{
      250, 270, 270, 270, 270, 270, 270, 250,
      270, 300, 320, 320, 320, 320, 300, 270,
      270, 320, 340, 350, 350, 340, 320, 270,
      270, 320, 350, 360, 360, 350, 320, 270,
      270, 320, 350, 360, 360, 350, 320, 270,
      270, 320, 340, 350, 350, 340, 320, 270,
      270, 300, 320, 320, 320, 320, 300, 270,
      250, 270, 270, 270, 270, 270, 270, 250
    }
  }
};
int[][][] BISHOP_VALUES = new int[][][]{
  //Opening material values for bishops based on square
  new int[][]{
    //black.
    new int[]{
      300, 320, 320, 320, 320, 320, 320, 300,
      320, 380, 340, 340, 340, 340, 380, 320,
      320, 340, 360, 360, 360, 360, 340, 320,
      320, 340, 360, 380, 380, 360, 340, 320,
      320, 340, 360, 380, 380, 360, 340, 320,
      320, 340, 360, 360, 360, 360, 340, 320,
      320, 340, 340, 340, 340, 340, 340, 320,
      300, 320, 320, 320, 320, 320, 320, 300
    },
    //white.
    new int[]{
      300, 320, 320, 320, 320, 320, 320, 300,
      320, 340, 340, 340, 340, 340, 340, 320,
      320, 340, 360, 360, 360, 360, 340, 320,
      320, 340, 360, 380, 380, 360, 340, 320,
      320, 340, 360, 380, 380, 360, 340, 320,
      320, 340, 360, 360, 360, 360, 340, 320,
      320, 380, 340, 340, 340, 340, 380, 320,
      300, 320, 320, 320, 320, 320, 320, 300
    }
  },
  //Endgame material values of bishops based on squares
  new int[][]{
    //black
    new int[]{
      350, 370, 370, 370, 370, 370, 370, 350,
      370, 390, 390, 390, 390, 390, 390, 370,
      370, 390, 410, 410, 410, 410, 390, 370,
      370, 390, 410, 430, 430, 410, 390, 370,
      370, 390, 410, 430, 430, 410, 390, 370,
      370, 390, 410, 410, 410, 410, 390, 370,
      370, 390, 390, 390, 390, 390, 390, 370,
      350, 370, 370, 370, 370, 370, 370, 350
    },
    //white
    new int[]{
      350, 370, 370, 370, 370, 370, 370, 350,
      370, 390, 390, 390, 390, 390, 390, 370,
      370, 390, 410, 410, 410, 410, 390, 370,
      370, 390, 410, 430, 430, 410, 390, 370,
      370, 390, 410, 430, 430, 410, 390, 370,
      370, 390, 410, 410, 410, 410, 390, 370,
      370, 390, 390, 390, 390, 390, 390, 370,
      350, 370, 370, 370, 370, 370, 370, 350
    }
  }
};


  public void settings() { size(1000, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ChessEngine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
